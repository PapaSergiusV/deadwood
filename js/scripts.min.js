/*jshint esversion: 6 */
class Entity 
{
  constructor(image, x, y, w, h, step) {
    this.entityImg = new Image();
    this.entityImg.src = image;
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.g = 0;
    this.jumping = false;
    this.step = step;
    this.dir = 1;
    this.backZone = 0;
  }
  draw(ctx) {
    ctx.beginPath();  
    ctx.drawImage(this.entityImg, this.x - this.w / 2, this.y - this.h, this.w, this.h);
    ctx.stroke();
  }
  gravity(relief, ms) {
    let h = relief[Math.floor((this.x + this.backZone) / 64)];
    if (this.y != h) {
      this.jumping = true;
      this.g++;
      let dy = Math.floor(this.g * ms / (25));
      if (this.y < h)
        this.y += dy;
      if (this.y > h) {
        this.y = h;
        this.g = 0;
      }
    }
    else
      this.jumping = false;
  }
  moving(direction, relief, ms) {
    let dx = direction * Math.floor(this.step * (ms / 25));
    let position = Math.floor(this.x / 32);
    if (relief[Math.floor((this.x + direction * (this.step + 6))/ 64)] >= this.y)
      this.x += dx;
    //Left wool
    if (this.x < 0)
      this.x = 0;
    //console.log(relief[Math.floor(this.x / 64)]);
    //console.log('moving');
  }
  jump() {
    this.y--;
    this.g = -13;
    this.jumping = true;
  }
}

class Player extends Entity
{
  setVars(point) {
    this.point = point;
    this.load = 0;
  }
  draw(ctx) {
    ctx.beginPath();  
    ctx.drawImage(this.entityImg, this.x - this.w / 2, this.y - this.h, this.w, this.h);
    ctx.stroke();
    if (this.load != 0)
      this.drawColl(ctx);
  }
  woodCollection() {
    this.point += Math.floor(Math.random() * 10);
  }
  drawColl(ctx) {
    let state = this.load;
    ctx.fillStyle = 'white';
    ctx.fillRect(this.x - 16, this.y - 74, 2 * state, 2);
    state = 16 - state;
    if (state != 0) {
      ctx.fillStyle = 'gray';
      ctx.fillRect(this.x + 16, this.y - 74, -2 * state, 2);
    }
  }
  moving(direction, relief, ms) {
    let dx = direction * Math.floor(this.step * (ms / 25));
    if (relief[Math.floor(((this.x + this.backZone) + direction * (this.step + 6))/ 64)] >= this.y)
      this.x += dx;
    //Left wool
    if (this.x < 0)
      this.x = 0;
    if (this.x > 320) {
      this.backZone += this.x - 320;
      this.x = 320;
    }
    //console.log(relief[Math.floor(this.x / 64)]);
    //console.log('moving');
  }
  request() {
    console.log('x=' + (this.x + this.backZone) + ' chank=' + Math.floor((this.x + this.backZone)/ 64));
  }
}

class Resources
{
  constructor(relief) {
    this.resImg = new Image();
    this.resImg.src = '../img/dwood.png';
    this.location = [];
    let length = relief.length * 2;
    for (var i = 0; i < length; i++) {
      if (Math.random() > 0.5)
        this.location[i] = relief[Math.floor(i / 2)] - 8;
      else
        this.location[i] = 0;
    }
  }
  draw(ctx, backZone) {
    let blindZoneL = Math.floor(backZone / 32);
    let blindZoneR = blindZoneL + 21 < this.location.length ? blindZoneL + 21 : this.location.length;
    for (var i = blindZoneL; i < blindZoneR; i++)
      if (this.location[i] != 0) {
        ctx.beginPath();  
        ctx.drawImage(this.resImg, i * 32 - backZone, this.location[i]);
        ctx.stroke();
      }
  }
  collection(player) { 
    this.location[Math.floor((player.x + player.backZone) / 32)] = 0;
  }
  isWood(x) {
    var area = Math.floor(x / 32);
    if (this.location[area] != 0)
      return true;
    else
      return false;
  }
}

class Background
{
  constructor() {
    this.woodImg = new Image();
    this.woodImg.src = '../img/wood.jpg';
    this.position = 0;
  }
  draw(ctx, player) {
    ctx.beginPath();
    if (this.position == 0 && player.x + player.backZone < 320) 
      ctx.drawImage(this.woodImg, 0, 0, 640, 400);
    else {
      let x = player.x + player.backZone;
      if (player.x == 320) {
        this.position = x;
        ctx.drawImage(this.woodImg, (160 - x / 2 + 640 * Math.floor((x - 320) / 1280)), 0, 640, 400);
        ctx.drawImage(this.woodImg, (800 - x / 2 + 640 * Math.floor((x - 320) / 1280)), 0, 640, 400);
      }
      else {
        ctx.drawImage(this.woodImg, (160 - this.position / 2 +
         640 * Math.floor((this.position - 320) / 1280)), 0, 640, 400);
        ctx.drawImage(this.woodImg, (800 - this.position / 2 +
         640 * Math.floor((this.position - 320) / 1280)), 0, 640, 400);
      }
    }
    ctx.stroke();
  }
}

class Ground
{
  constructor(image, length) {
    this.relief = [];
    this.grassImg = new Image();
    this.grassImg.src = image;
    for (var i = 0; i < length; i++) {
      this.relief[i] = 400 - (Math.floor(Math.random() * (3 - 1)) + 1) * 32;
    }
  }
  //Рисование рельефа
  draw(ctx, backZone) {
    let blindZoneL = Math.floor(backZone / 64);
    let blindZoneR = blindZoneL + 11 < this.relief.length ? blindZoneL + 11 : this.relief.length;
    for (var i = blindZoneL; i < blindZoneR; i++) {
      var rand = this.relief[i];
      ctx.beginPath();  
      ctx.drawImage(this.grassImg, i * 64 - backZone, rand);
      ctx.stroke();
    }
  }
}

class Interface
{
  constructor() {

  }
  draw(ctx, x, y, point, ms) {
    ctx.fillStyle = '#333333';
    ctx.strokeStyle = '#000';
    ctx.fillRect(10, 10, 620, 40);
    ctx.font = '20pt Roboto';
    ctx.fillStyle = '#eee';
    ctx.fillText('X:' + x + '   Y:' + y + '   Score:' + point + '   FPS:' + Math.floor(1000 / ms), 15, 35);
  }
}

class Fire 
{
  constructor(image, w, h) {
    this.w = w;
    this.h = h;
    this.image = new Image();
    this.image.src = image;
  }
  draw(ctx, x, y) {
    ctx.beginPath();  
    ctx.drawImage(this.image, x - this.w / 2, y - this.h / 2);
    ctx.stroke();
  }
}

class DWFuncs
{
  constructor() {}
  //Deadwood collection function
  static collManager(player, dwood) {
    let position = Math.floor(player.x / 32);
    if (dwood.isWood(player.x + player.backZone) && !player.jumping) {
      //Функция отображения сбора дерева
      let i = 0;
      let loading = setInterval(function() {
        i++;
        player.load = i;
      }, 50);
      //Функция сбора дерева
      setTimeout(function() {
        if (position == Math.floor(player.x / 32) && !player.jumping) {
          player.woodCollection();
          dwood.collection(player);
        }
        clearInterval(loading);
        player.load = 0;
      }, 850);
      // +++ Добавить функцию прерывания всего при прыжке и т.д.
    }
  }
}
/*jshint esversion: 6 */
//Переменные common.js
let frame = 0;
let screen = document.getElementById('screen');
let ctx = screen.getContext('2d');
let time = new Date();
let ms = 20;
let mapLength = 100;

//Инициализация объектов классов
let wood = new Background();
let ground = new Ground('../img/grass.jpg', mapLength);
let player = new Player('../img/player.png', 16, 300, 32, 64, 2.3);
    player.setVars(0);
let dwood = new Resources(ground.relief);
let scores = new Interface(); 
let torch = new Fire('../img/fireInTheDark.png', 1280, 800);
 
//Вызовы главных функций 
addEventListener("keypress", keyListener); 
addEventListener("keydown", keyListener);
if (ctx) setInterval(render, 25);

//Функция отслеживания нажатия клавиш
function keyListener(e){
  var k = e.keyCode;
  if (k == 100 || k == 68)              player.moving(1, ground.relief, ms);
  else if (k == 97 || k == 65)          player.moving(-1, ground.relief, ms);
  else if (k == 16 && !player.jumping)  player.jump();
  else if (k == 115)                    DWFuncs.collManager(player, dwood);
}

//Главная функция игры
function render() {
  ms = new Date() - time;
  time = new Date();

  player.gravity(ground.relief, ms);

  wood.draw(ctx, player);
  ground.draw(ctx, player.backZone);
  dwood.draw(ctx, player.backZone);
  player.draw(ctx);
  torch.draw(ctx, player.x, player.y - 48);
  scores.draw(ctx, player.x + player.backZone, player.y, player.point, ms);  

  frame++; 
}